import * from examples.test2

printPairs :: List{Int} -> IO
printPairs [] = do
  println "Done"
end
printPairs (x:y:xs) = do
  print (^x) : " " : (^y) : "\n"
  printPairs xs
end

fact :: Int -> Int
fact n = do
  if n == 0 then do
    1
  else do
    n * fact ((n) - 1)
  end
end

addOne :: Int -> Int
addOne n = n + 1

add :: Int -> Int -> Int
add x y = x + y

call :: Fn {Int -> Int => Int} -> IO
call f = do
  println (f 10)
end

struct Point = (x: Int, y: Int)

bla :: Int -> Int -> Int
bla x y = x + y

something :: Int -> Int -> Int
something x y = x + y

something :: Float -> Float -> Float
something x y = x * y

println :: Point -> IO
println p = do
  print p.x : " " : p.y : "\n"
end

ppp :: Int -> Int -> Int
ppp x y = do
  println x
  println y
  println "----"
  x + y
end

mySum :: List{Float} -> Float
mySum [] = 0.0
mySum (x:xs) = x + mySum xs


struct Animal = (name: String)

struct Bla = (num: Int)

trait Animal = do
  makeNoise :: Self -> IO
end

impl Animal for Dog = do
  makeNoise self = println "Woof"
end

impl Animal for Cat = do
  makeNoise self = println "Meow"
end

doing :: Int -> Int
doing x = do
  let testL = 123
  x + testL
end

beAnimal :: Animal -> IO
beAnimal a = do
  makeNoise a
end


main => IO = do
  # let blalbl = foldl (ppp), 0.0, [2.0,4.0,8.0]
  # println blalbl
  # println (mySum [2.0,4.0,8.0])
  let blaa = 10
  let bello = Dog { name: "Bello" }
  let minka = Cat { name: "Minka" }
  # println "Hello World"
  # makeNoise minka
  # makeNoise bello
  # println name bello
  # println name minka
  # println map name, [bello, minka] # TODO: This should work, fix partial function finding
  # println map addOne, [1,2,3,4,5]
  # println map (\a -> a + blaa), [1,2,3,4,5]
  # println testL
  beAnimal bello
  beAnimal minka
end
