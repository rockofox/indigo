import * from examples/test2 as test2

printPairs :: List{Int} -> IO
printPairs [] = do
  println "Done"
end
printPairs (x:y:xs) = do
  print (^x) : " " : (^y) : "\n"
  printPairs xs
end

fact :: Int -> Int
fact n = do
  if n == 0 then do
    1
  else do
    n * fact ((n) - 1)
  end
end

addOne :: Int -> Int
addOne n = n + 1

add :: Int -> Int -> Int
add x y = x + y

call :: Fn {Int -> Int => Int} -> IO
call f = do
  println (f 10)
end

struct Point = (x: Int, y: Int)

bla :: Int -> Int -> Int
bla x y = x + y

something :: Int -> Int -> Int
something x y = x + y

something :: Float -> Float -> Float
something x y = x * y

println :: Point -> IO
println p = do
  print p.x : " " : p.y : "\n"
end

ppp :: Int -> Int -> Int
ppp x y = do
  println x
  println y
  println "----"
  x + y
end

mySum :: List{Float} -> Float
mySum [] = 0.0
mySum (x:xs) = x + mySum xs


struct Animal = (name: String)

struct Bla = (num: Int)

trait Animal = do
  makeNoise :: Self -> IO
end

impl Animal for Dog = do
  makeNoise self = println "Woof"
end

impl Animal for Cat = do
  makeNoise self = println "Meow"
end

doing :: Int -> Int
doing x = do
  let testL = 123
  x + testL
end

beAnimal :: Animal -> IO
beAnimal a = do
  makeNoise a
end

testInside :: Int -> Int -> Int
testInside a b = do
   let blaaaa => Int = 24
   addIt :: Int -> Int -> Int
   addIt t u = t + u + blaaaa
   addIt a, b
end
bottles :: Int -> IO
bottles i = do
  if i > 0 then do
    println ^i : " bottles of beer on the wall, " : ^i : " bottles of beer."
    println "Take one down and pass it around, " : ((i) - 1) as String : " bottles of beer on the wall.\n"
    bottles (i)-1
  else do
    println "No more bottles of beer on the wall, no more bottles of beer."
    println "Go to the store and buy some more, 99 bottles of beer on the wall."
  end
end

# fib :: Int -> Int
# fib 0 = 0
# fib 1 = 1
# fib n = (fib ((n) - 2)) + (fib ((n) - 1))       # Fix recursion

let fib (0: Int) => Int = 0
let fib (1: Int) => Int = 1
let fib (n: Int) => Int = (fib ((n) - 2)) + (fib ((n) - 1))

# fib :: Int -> Int
# let fibClassic (n: Int) => Int = do
#   if n == 0 then do
#     0
#   else do
#     if n == 1 then do
#       1
#     else do
#       (fibClassic ((n) - 1)) + (fibClassic ((n) - 2))
#     end
#   end
# end

# println (fib 9)

# let blaTest ([]: List{Int}) => Int = do
#   0
# end
# let blaTest ((b:bs): List{Int}) => Int = do
#   b + (blaTest bs)
# end
#
# println blaTest [1,2,3,4,5]
# println fib 1
# println fib 1
# println fib 15
# println fibClassic 9

# let main => IO = _ # TODO: Automatically generate stub main if there's no main function
let main => IO = do
  let cities = ["London", "Oslo", "Paris", "Amsterdam", "Berlin"]
  let visited = ["Berlin", "Oslo"]
  let linus = 123
  println map (\a -> "I still need to visit " : a : "!" : "\n"), ((cities)-(visited))
  println map (\a -> a + 2), [1,2,3,4,5]
end

# let main => IO = do
#   # let blalbl = foldl (ppp), 0.0, [2.0,4.0,8.0]
#   # println blalbl
#   # println (mySum [2.0,4.0,8.0])
#   let blaa = 10
#   let bello = Dog { name: "Bello" }
#   let minka = Cat { name: "Minka" }
#
#   println (fib 9)
#   # bottles 99
#
#   # let blaaaa = 12
#   #
#   # let square (a: Int) = a * a
#   # (square 10) |> square |> println >> println "Hello World"
#   #
#   # println test2@bla 10, 20
#
#   # println "Hello World"
#   # makeNoise minka
#   # makeNoise bello
#   # println name bello
#   # println name minka
#   # println map name, [bello, minka] # TODO: This should work, fix partial function finding
#   # println map addOne, [1,2,3,4,5]
#   # println map (\a -> a + blaa), [1,2,3,4,5]
#   # println testL
#   # beAnimal bello
#   # beAnimal minka
#   # addIt 2,4
#   # println testInside 2, 4
#   # println blaaaa
# end


